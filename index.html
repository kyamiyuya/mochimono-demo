<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>持ち物AIデモ（Phase1）</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#2563EB" />
  <style>
    :root{--b:#2563EB;--g:#10B981;--bg:#0b1220;--card:#111a2e;--mut:#9aa4b2;}
    body{font-family:system-ui,-apple-system,"Hiragino Sans","Yu Gothic",sans-serif;margin:0;background:#0b1220;color:#e7eefc;}
    header{padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;gap:12px;align-items:center;justify-content:space-between;}
    header h1{font-size:16px;margin:0;font-weight:700;}
    header .tag{font-size:12px;color:#b7c3d6}
    main{padding:14px;display:grid;gap:14px;grid-template-columns:1.2fr .8fr;}
    @media (max-width: 900px){main{grid-template-columns:1fr;}}
    .card{background:#111a2e;border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden;}
    .card h2{font-size:13px;margin:0;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);color:#cfe0ff;}
    .pad{padding:12px;}
    button{background:var(--b);border:none;color:white;padding:10px 12px;border-radius:10px;font-weight:700;cursor:pointer;}
    button.secondary{background:#243252}
    button.danger{background:#b91c1c}
    button:disabled{opacity:.55;cursor:not-allowed}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .hint{font-size:12px;color:var(--mut)}
    .videoWrap{position:relative;background:black;aspect-ratio:16/9;}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;}
    canvas{pointer-events:none;}
    .stat{display:flex;gap:12px;align-items:center;margin-top:10px;flex-wrap:wrap}
    .pill{font-size:12px;background:rgba(37,99,235,.18);border:1px solid rgba(37,99,235,.35);padding:6px 10px;border-radius:999px}
    .pill.good{background:rgba(16,185,129,.15);border-color:rgba(16,185,129,.35)}
    .list{display:grid;gap:8px}
    .item{display:grid;grid-template-columns:56px 1fr;gap:10px;align-items:center;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:8px}
    .thumb{width:56px;height:56px;border-radius:10px;background:#0b1220;object-fit:cover;border:1px solid rgba(255,255,255,.08)}
    .meta{display:flex;gap:8px;align-items:baseline;flex-wrap:wrap}
    .name{font-weight:800}
    .conf{font-size:12px;color:#b7c3d6}
    .time{font-size:11px;color:#8aa0c5}
    .footerNote{font-size:11px;color:#9aa4b2;line-height:1.5}
    code{background:rgba(255,255,255,.06);padding:2px 6px;border-radius:8px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>持ち物AIデモ（Phase1）</h1>
      <div class="tag">カメラ映像 → 中央だけ検出（ROI） → 枠表示 → リスト化（端末内処理）</div>
    </div>
    <div class="tag">AI: TensorFlow.js（無料）</div>
  </header>

  <main>
    <section class="card">
      <h2>1) カメラ & 検出</h2>
      <div class="pad">
        <div class="row">
          <button id="btnCam">カメラ開始</button>
          <button id="btnStart" class="secondary" disabled>検出開始</button>
          <button id="btnStop" class="secondary" disabled>検出停止</button>
          <button id="btnClear" class="danger" disabled>結果クリア</button>
        </div>
        <div class="hint" style="margin-top:8px">
          ※iPad/スマホは<strong>HTTPS</strong>でないとカメラが使えません（GitHub Pages）。
        </div>

        <div class="videoWrap" style="margin-top:12px">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>

        <div class="stat">
          <div class="pill" id="modelState">モデル: 未読込</div>
          <div class="pill good">画像送信: なし（端末内処理）</div>
          <div class="pill" id="fps">推論間隔: -</div>
        </div>

        <div class="footerNote" style="margin-top:10px">
          ・このデモは「画面中央の点線枠」内だけを検出します（負荷軽減）。<br/>
          ・ラベルは一部を日本語化しています（辞書に無いものは英語のまま）。
        </div>
      </div>
    </section>

    <aside class="card">
      <h2>2) 検出結果（リスト）</h2>
      <div class="pad">
        <div class="hint">同じ物体名は短時間はまとめます（重複抑制）。</div>
        <div id="list" class="list" style="margin-top:10px"></div>
        <div class="footerNote" style="margin-top:10px">
          公開URL：<code>https://kyamiyuya.github.io/mochimono-demo/</code>
        </div>
      </div>
    </aside>
  </main>

  <!-- TensorFlow.js & COCO-SSD (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

  <script>
    const els = {
      btnCam: document.getElementById('btnCam'),
      btnStart: document.getElementById('btnStart'),
      btnStop: document.getElementById('btnStop'),
      btnClear: document.getElementById('btnClear'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      list: document.getElementById('list'),
      modelState: document.getElementById('modelState'),
      fps: document.getElementById('fps'),
    };

    let stream = null;
    let model = null;
    let timer = null;

    // ★負荷調整：推論間隔（長いほど軽い）
    const DETECT_EVERY_MS = 2000;
    els.fps.textContent = `推論間隔: ${DETECT_EVERY_MS}ms`;

    // ★中央ROI：画面中央60%×60%のみ検出
    const ROI_SCALE = 0.60;

    // ★検出閾値
    const MIN_SCORE = 0.55;

    // 重複抑制（同じクラスは一定時間以内は更新のみ）
    const lastSeen = new Map();
    const DEDUPE_MS = 4000;

    // COCO-SSD 英語→日本語（必要に応じて追加できます）
    const JP_LABEL = {
      'person':'人',
      'bottle':'ボトル',
      'cup':'コップ',
      'backpack':'リュック',
      'handbag':'バッグ',
      'suitcase':'スーツケース',
      'book':'本',
      'cell phone':'携帯電話',
      'toothbrush':'歯ブラシ',
      'tie':'ネクタイ',
      'umbrella':'傘',
      'remote':'リモコン',
      'keyboard':'キーボード',
      'mouse':'マウス',
      'laptop':'ノートPC',
      'tv':'テレビ',
      'chair':'椅子',
      'couch':'ソファ',
      'bed':'ベッド',
      'dining table':'テーブル',
      'refrigerator':'冷蔵庫',
      'scissors':'はさみ',
      'bowl':'ボウル',
      'fork':'フォーク',
      'knife':'ナイフ',
      'spoon':'スプーン'
    };
    function toJP(label){ return JP_LABEL[label] || label; }

    function nowStr(){
      const d=new Date();
      return d.toLocaleTimeString('ja-JP',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
    }

    function resizeCanvas(){
      const rect = els.video.getBoundingClientRect();
      const c = els.overlay;
      c.width = Math.floor(rect.width * devicePixelRatio);
      c.height = Math.floor(rect.height * devicePixelRatio);
    }

    function getRoiRect(){
      const rect = els.video.getBoundingClientRect();
      const w = rect.width * ROI_SCALE;
      const h = rect.height * ROI_SCALE;
      return { x:(rect.width-w)/2, y:(rect.height-h)/2, w, h, rect };
    }

    function drawRoiFrame(){
      const ctx = els.overlay.getContext('2d');
      ctx.save();
      ctx.scale(devicePixelRatio, devicePixelRatio);

      // ROI枠だけ描く場合はクリアしない（boxes描画時は別でクリア）
      const roi = getRoiRect();
      ctx.strokeStyle = 'rgba(147,197,253,0.95)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
      ctx.setLineDash([]);

      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.font = '12px system-ui';
      ctx.fillText('検出エリア（中央）', roi.x+6, Math.max(14, roi.y-6));
      ctx.restore();
    }

    window.addEventListener('resize', ()=>{ resizeCanvas(); });

    async function loadModel(){
      if(model) return model;
      els.modelState.textContent = 'モデル: 読込中…（初回は30〜90秒かかる場合があります）';
      model = await cocoSsd.load();
      els.modelState.textContent = 'モデル: 準備OK';
      return model;
    }

    async function startCamera(){
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' } },
        audio: false
      });
      els.video.srcObject = stream;
      await els.video.play();
      resizeCanvas();
      // 初期表示：ROI枠を表示
      const ctx = els.overlay.getContext('2d');
      ctx.clearRect(0,0,els.overlay.width, els.overlay.height);
      drawRoiFrame();
      els.btnStart.disabled = false;
      els.btnClear.disabled = false;
    }

    function clearResults(){
      lastSeen.clear();
      els.list.innerHTML='';
      const ctx = els.overlay.getContext('2d');
      ctx.clearRect(0,0,els.overlay.width, els.overlay.height);
      if(stream) drawRoiFrame();
    }

    function draw(predictions){
      const ctx = els.overlay.getContext('2d');
      ctx.save();
      ctx.scale(devicePixelRatio, devicePixelRatio);
      ctx.clearRect(0,0,els.overlay.width, els.overlay.height);

      const vRect = els.video.getBoundingClientRect();
      const scaleX = vRect.width / els.video.videoWidth;
      const scaleY = vRect.height / els.video.videoHeight;

      ctx.lineWidth = 2;
      ctx.font = '12px system-ui';

      predictions.forEach(p=>{
        const [x,y,w,h] = p.bbox; // video座標
        const sx = x*scaleX, sy = y*scaleY, sw = w*scaleX, sh = h*scaleY;

        ctx.strokeStyle = 'rgba(16,185,129,0.95)';
        ctx.fillStyle = 'rgba(16,185,129,0.18)';
        ctx.strokeRect(sx,sy,sw,sh);
        ctx.fillRect(sx,sy,sw,sh);

        const label = `${toJP(p.class)} ${(p.score*100).toFixed(0)}%`;
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        const tw = ctx.measureText(label).width + 8;
        ctx.fillRect(sx, Math.max(0,sy-18), tw, 18);
        ctx.fillStyle = '#fff';
        ctx.fillText(label, sx+4, Math.max(12,sy-6));
      });

      // 最後にROI枠を重ねる
      drawRoiFrame();
      ctx.restore();
    }

    function cropThumb(p){
      const v = els.video;
      const [x,y,w,h] = p.bbox;
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      const cw = Math.max(1, Math.floor(w));
      const ch = Math.max(1, Math.floor(h));
      c.width = cw; c.height = ch;
      ctx.drawImage(v, x, y, w, h, 0, 0, cw, ch);
      return c.toDataURL('image/jpeg', 0.75);
    }

    function upsertList(p, thumb){
      const key = p.class;
      const displayName = toJP(p.class);
      const t = Date.now();
      const old = lastSeen.get(key);

      if(old && (t - old.t) < DEDUPE_MS){
        lastSeen.set(key, {t, conf:p.score, thumb});
        const el = document.querySelector(`[data-key="${CSS.escape(key)}"]`);
        if(el){
          el.querySelector('.conf').textContent = `${(p.score*100).toFixed(0)}%`;
          el.querySelector('.time').textContent = `更新: ${nowStr()}`;
          el.querySelector('.name').textContent = displayName;
          if(thumb) el.querySelector('img').src = thumb;
        }
        return;
      }

      lastSeen.set(key, {t, conf:p.score, thumb});
      const item = document.createElement('div');
      item.className='item';
      item.dataset.key = key;
      item.innerHTML = `
        <img class="thumb" alt="thumb" />
        <div>
          <div class="meta">
            <div class="name"></div>
            <div class="conf"></div>
          </div>
          <div class="time"></div>
        </div>
      `;
      item.querySelector('.name').textContent = displayName;
      item.querySelector('.conf').textContent = `${(p.score*100).toFixed(0)}%`;
      item.querySelector('.time').textContent = `検出: ${nowStr()}`;
      item.querySelector('img').src = thumb || '';
      els.list.prepend(item);
    }

    async function detectOnce(){
      if(!model || !els.video.videoWidth) return;

      // 画面中央ROIのみを切り出して検出（軽量化）
      const roi = getRoiRect();

      // 表示座標 -> video座標へ変換
      const sx = els.video.videoWidth / roi.rect.width;
      const sy = els.video.videoHeight / roi.rect.height;

      const srcX = roi.x * sx;
      const srcY = roi.y * sy;
      const srcW = roi.w * sx;
      const srcH = roi.h * sy;

      const roiCanvas = document.createElement('canvas');
      roiCanvas.width = Math.max(1, Math.floor(srcW));
      roiCanvas.height = Math.max(1, Math.floor(srcH));
      const rctx = roiCanvas.getContext('2d');
      rctx.drawImage(els.video, srcX, srcY, srcW, srcH, 0, 0, roiCanvas.width, roiCanvas.height);

      const preds = await model.detect(roiCanvas);

      // ROI内座標 -> 元動画座標へ戻す
      const filtered = preds
        .filter(p=>p.score >= MIN_SCORE)
        .map(p=>({
          ...p,
          bbox: [p.bbox[0] + srcX, p.bbox[1] + srcY, p.bbox[2], p.bbox[3]]
        }));

      draw(filtered);

      filtered.slice(0,6).forEach(p=>{
        let thumb=null;
        try{ thumb = cropThumb(p); }catch(e){}
        upsertList(p, thumb);
      });
    }

    async function startDetect(){
      await loadModel();
      els.btnStart.disabled = true;
      els.btnStop.disabled = false;
      timer = setInterval(detectOnce, DETECT_EVERY_MS);
    }

    function stopDetect(){
      els.btnStart.disabled = !stream;
      els.btnStop.disabled = true;
      if(timer){ clearInterval(timer); timer=null; }
      // 停止時もROI枠は表示
      const ctx = els.overlay.getContext('2d');
      ctx.clearRect(0,0,els.overlay.width, els.overlay.height);
      if(stream) drawRoiFrame();
    }

    // PWA: SW登録
    if('serviceWorker' in navigator){
      window.addEventListener('load', ()=>{
        navigator.serviceWorker.register('./service-worker.js').catch(()=>{});
      });
    }

    els.btnCam.addEventListener('click', async ()=>{
      try{
        els.btnCam.disabled = true;
        await startCamera();
        els.btnCam.textContent = 'カメラ起動中';
      }catch(err){
        alert('カメラ起動に失敗しました。HTTPSで開いているか、カメラ許可がONか確認してください。');
        els.btnCam.disabled = false;
      }
    });

    els.btnStart.addEventListener('click', startDetect);
    els.btnStop.addEventListener('click', stopDetect);
    els.btnClear.addEventListener('click', clearResults);
  </script>
</body>
</html>
